<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Javascript La Guia Definitiva Sexta Edicion</title>
</head>

<body>
    <div>
        <p id="E6-2">
            El ejemplo 6-2 define funciones de utilidad que usan bucles <code>for/in</code> para manipular objetos
            propuestos.
            Erties de maneras útiles. La función <code>extend()</code>, en particular, es una que es comúnmente
            incluido en las bibliotecas de utilidades de JavaScript.<sup>2</sup>
        </p>
        <footer>
            2. La implementación de <code>extend()</code> que se muestra aquí es correcta pero no compensa un error
            conocido en
            Internet Explorer. Veremos una versión más robusta de <code>extend()</code> en el Ejemplo 8-3.
        </footer>
    </div>
    <div>
        <p>
            <h3>7.8.6 splice()</h3>
            El método <code>Array.splice()</code> es un método de propósito general para insertar o eliminar
            elementos de una matriz. A diferencia de <code>slice()</code> y <code>concat()</code>, <code>splice()</code>
            modifica la matriz en
            que se invoca Tenga en cuenta que <code>splice()</code> y <code>slice()</code> tienen nombres muy similares
            pero realizan operaciones sustancialmente diferentes.
            <code>splice()</code> puede eliminar elementos de una matriz, insertar nuevos elementos en una matriz o
            realizar
            ambas operaciones al mismo tiempo.Los elementos de la matriz que vienen después del punto de inserción o
            eliminación aumentan o disminuyen sus índices según sea necesario para que
            permanezcan contiguos con el resto de la matriz. El primer argumento para <code>splice()</code> especifica
            la posición de la matriz en la que debe comenzar la inserción y / o eliminación. El segundo
            argumento especifica el número de elementos que deben eliminarse (dividirse)
            la matriz Si se omite este segundo argumento, todos los elementos de la matriz del elemento inicial
            al final de la matriz se eliminan. <code>splicegit()</code> devuelve una matriz de los elementos eliminados,
            o una matriz vacía si no se eliminaron elementos. Por ejemplo:
        </p>
        <code>
            <pre>
                var a = [1,2,3,4,5,6,7,8];
                a.splice(4);    // Returns [5,6,7,8]; a is [1,2,3,4]
                a.splice(1,2);  // Returns [2,3]; a is [1,4]
                a.splice(1,1);  // Returns [4]; a is [1]
            </pre>
        </code>
        <p>
            Los primeros dos argumentos para <code>splice()</code> especifican qué elementos de la matriz se deben
            eliminar.
            Estos argumentos pueden ser seguidos por cualquier número de argumentos adicionales que especifiquen
            elementos que se insertarán en la matriz, comenzando en la posición especificada por el primer
            argumento. Por ejemplo:
            <code>
                <pre>
                var a = [1,2,3,4,5];
                a.splice(2,0,'a','b'); // Returns []; a is [1,2,'a','b',3,4,5]
                a.splice(2,2,[1,2],3); // Returns ['a','b']; a is [1,2,[1,2],3,3,4,5]
                </pre>
</code>
            Tenga en cuenta que, a diferencia de <code>concat()</code>, <code>splice()</code> inserta matrices en sí, no
            los elementos de esas matrices.
        </p>
    </div>
    <div>
        <h3>7.8.7 push() y pop() </h3>
        <p>
            Los métodos <code>push()</code> y <code>pop()</code> le permiten trabajar con matrices como si fueran pilas.
            El método <code>push()</code> agrega uno o más elementos nuevos al final de una matriz y
            devuelve la nueva longitud de la matriz. El método <code>pop()</code> hace lo contrario: elimina el
            último elemento de una matriz, disminuye la longitud de la matriz y devuelve el valor que
            remoto. Tenga en cuenta que ambos métodos modifican la matriz en su lugar en lugar de producir un
            copia modificada de la matriz. La combinación de <code>push()</code> y <code>pop()</code> le permite usar un
            Matriz de JavaScript para implementar una pila de primero en entrar, último en salir. Por ejemplo:
            <code>
    <pre>
        var stack = [];    // stack: []
        stack.push(1,2);   // stack: [1,2]     Returns 2
        stack.pop();       // stack: [1]       Returns 2
        stack.push(3);     // stack: [1,3]     Returns 2
        stack.pop();       // stack: [1]       Returns 3
        stack.push([4,5]); // stack: [1,[4,5]] Returns 2
        stack.pop()        // stack: [1]       Returns [4,5]
        stack.pop();       // stack: []        Returns 1
    </pre>
</code>
        </p>
    </div>
    <div>

        <h3>7.8.8 unshift() y shift()</h3>
        <p>
            Los métodos <code>unshift()</code> y <code>shift()</code> se comportan de manera similar a
            <code>push()</code> y <code>pop()</code>,
            excepto que insertan y eliminan elementos desde el principio de una matriz en lugar de desde el final.
            <code>unshift()</code> agrega un elemento o elementos al comienzo de la matriz,
            desplaza los elementos de la matriz existentes a índices más altos para hacer espacio y devuelve la nueva
            longitud de la matriz.
            <code>shift()</code> elimina y devuelve el primer elemento de la matriz,
            desplazando todos los elementos subsiguientes hacia abajo un lugar para ocupar el espacio recientemente
            vacante al comienzo de la matriz.
            Por ejemplo:
            <code>
        <pre>
                var a = [];           // a: []
                a.unshift(1);         // a: [1]          Returns: 1
                a.unshift(22);        // a: [22,1]       Returns: 2
                a.shift();            // a: [1]          Returns: 22
                a.unshift(3,[4,5]);   // a: [3,[4,5],1]  Returns: 3
                a.shift();            // a: [[4,5],1]    Returns: 3
                a.shift();            // a: [1]          Returns: [4,5]
                a.shift();            // a: []           Returns: 1
        </pre>
    </code>
            Tenga en cuenta el comportamiento posiblemente sorprendente de <code>unshift()</code> cuando se invoca con
            múltiples argumentos.
            En lugar de insertarse en la matriz de uno en uno, los argumentos se insertan de una vez (como con el método
            <code>splice()</code> ).
            Esto significa que aparecen en la matriz resultante en el mismo orden en que aparecieron en la lista de
            argumentos.
            Si los elementos se hubieran insertado uno a la vez, su orden se habría invertido.
        </p>
    </div>
    <div>
        <p>
            <h3>7.8.9 toString() y toLocaleString()</h3>
            Una matriz, como cualquier objeto JavaScript, tiene un método <code>toString()</code>. Para una matriz, este
            método
            convierte cada uno de sus elementos en una cadena (llamando a los métodos <code>toString()</code> de sus
            elementos, si
            es necesario) y genera una lista separada por comas de esas cadenas.
            Tenga en cuenta que la salida no incluye corchetes ni ningún otro tipo de delimitador alrededor del valor de
            la matriz. Por ejemplo:
            <code>
                <pre>
                [1,2,3].toString()          // Produce '1,2,3'
                ["a", "b", "c"].toString()  // Produce 'a,b,c'
                [1, [2,'c']].toString()     // Produce '1,2,c'
                </pre>
            </code>
            Tenga en cuenta que el método <code>join()</code> devuelve la misma cadena cuando se invoca sin argumentos.
            <code>toLocaleString()</code> es la versión localizada de <code>toString()</code>. Convierte cada elemento
            de la matriz en una
            cadena al llamar al método <code>toLocaleString()</code> del elemento, y luego concatena las cadenas
            resultantes
            utilizando una cadena de separación local específica (y definida por la implementación).
        </p>
    </div>
    <div>
        <p>
            <h2>7.9 ECMAScript 5 Métodos de matriz</h2>
            ECMAScript 5 define nueve nuevos métodos de matriz para iterar, mapear, filtrar, probar, reducir y buscar
            matrices. Las subsecciones a continuación describen estos métodos.<br></br>
            Sin embargo, antes de cubrir los detalles, vale la pena hacer algunas generalizaciones sobre estos métodos
            de matriz ECMAScript 5. Primero, la mayoría de los métodos aceptan una función como su primer argumento e
            invocan esa función una vez para cada elemento (o algunos elementos) de la matriz. Si la matriz es escasa,
            la función que pasa no se invoca para elementos inexistentes. En la mayoría de los casos, la función que
            proporciona se invoca con tres argumentos: el valor del elemento de matriz, el índice del elemento de matriz
            y la matriz misma. A menudo, solo necesita el primero de estos valores de argumento y puede ignorar los
            valores segundo y tercero. La mayoría de los métodos de matriz ECMAScript 5 que aceptan una función como su
            primer argumento aceptan un segundo argumento opcional. Si se especifica, la función se invoca como si fuera
            un método de este segundo argumento. Es decir, el segundo argumento que pasa se convierte en el valor de la
            palabra clave this dentro de la función que pasa. El valor de retorno de la función que pasa es importante,
            pero diferentes métodos manejan el valor de retorno de diferentes maneras. Ninguno de los métodos de matriz
            ECMAScript 5 modifica la matriz en la que se invoca. Si pasa una función a estos métodos, esa función puede
            modificar la matriz, por supuesto.

        </p>
    </div>
    <div>
        <p>
            <h3>7.9.1 forEach()</h3>
            El método <code>forEach()</code> itera a través de una matriz, invocando una función que especifique para
            cada elemento.
            Como se describió anteriormente, pasa la función como primer argumento a <code>forEach()</code>.
            <code>forEach()</code> invoca su
            función con tres argumentos: el valor del elemento de matriz, el índice del elemento de matriz y la matriz
            misma. Si solo te importa
            el valor del elemento de matriz, puede escribir una función con solo un parámetro, los argumentos
            adicionales serán ignorados:

            <code>
              <pre>
                    var data = [1,2,3,4,5];                           // Una matriz para sumar
                    // Calcule la suma de los elementos de la matriz.
                    var sum = 0;                                      // Start at 0
                    data.forEach(function(value) { sum += value; });  // Add each value to sum
                    sum                                               // => 15
                               
                    // Now increment each array element
                    data.forEach(function(v, i, a) { a[i] = v + 1; });
                    data                                              // => [2,3,4,5,6]
        
              </pre>
          </code>
            Tenga en cuenta que <code>forEach()</code> no proporciona una forma de terminar la iteración antes de que
            todos los
            elementos hayan pasado a la función. Es decir, no existe un equivalente de la declaración de ruptura que
            pueda usar con un ciclo for regular. Si necesita terminar antes, debe lanzar una excepción y colocar la
            llamada a <code>forEach()</code> dentro de un bloque de prueba. El siguiente código define una función
            <code>foreach()</code> que
            llama al método <code>forEach()</code> dentro de dicho bloque <code>try</code> . Si la función pasada a
            <code>foreach()</code> arroja
            <code>foreach.break</code>, el ciclo terminará antes:
            <code>
            <pre>
                    function foreach(a,f,t) {
                        try { a.forEach(f,t); }
                        catch(e) {
                            if (e === foreach.break) return;
                            else throw e;
                            }
                            }
                            foreach.break = new Error("StopIteration");
            </pre>
        </code>
        </p>
    </div>
    <div>
        <p>
            <h3>7.9.2 map()</h3>
            El método <code>map()</code> pasa cada elemento de la matriz en la que se invoca a la función que
            especifique, y
            devuelve una matriz que contiene los valores devueltos por esa función. Por ejemplo:
            <code>
                    <pre>
                            a = [1, 2, 3];
                            b = a.map(function(x) { return x*x; });  // b is [1, 4, 9]
                    </pre>
                </code>
            La función que pasa a <code>map()</code> se invoca de la misma manera que una función pasada a forEach ().
            Sin embargo,
            para el método <code>map()</code>, la función que pasa debe devolver un valor. Tenga en cuenta que
            <code>map()</code> devuelve una
            nueva matriz: no modifica la matriz en la que se invoca. Si esa matriz es escasa, la matriz devuelta será
            escasa de la misma manera: tendrá la misma longitud y los mismos elementos faltantes.
        </p>
    </div>
    <div>
        <p>
            <h3>7.9.3 filter()</h3>
            El método <code>filter()</code> devuelve una matriz que contiene un subconjunto de los elementos de la
            matriz en la que
            se invoca. La función que le pasas debe ser predicado: una función que devuelve verdadero o falso. El
            predicado se invoca como para <code>forEach()</code> y <code>map()</code>. Si el valor de retorno es
            verdadero, o un valor que se
            convierte en verdadero, entonces el elemento pasado al predicado es un miembro del subconjunto y se agrega a
            la matriz que se convertirá en el valor de retorno. Ejemplos:
            <code>
                <pre>
                        a = [5, 4, 3, 2, 1];
                        smallvalues = a.filter(function(x) { return x < 3 });   // [2, 1]
                        everyother = a.filter(function(x,i) { return i%2==0 }); // [5, 3, 1]
                </pre>
            </code>
            Tenga en cuenta que <code>filter()</code> omite elementos faltantes en matrices dispersas y que su valor de
            retorno es
            siempre denso. Para cerrar las brechas en una matriz dispersa, puede hacer esto:
            <code>
                <pre>
                        var dense = sparse.filter(function() { return true; });
                </pre>
            </code>
            Y para cerrar huecos y eliminar elementos indefinidos y nulos, puede usar filtros como este:
            <code>
                <pre>
                        a = a.filter(function(x) { return x !== undefined && x != null; });
                </pre>
            </code>
        </p>
    </div>
    <div>
        <p>
            <h3>7.9.4 every() y some()</h3>
            Los métodos <code>every()</code> y <code>some()</code> son predicados de matriz: aplican una función de
            predicado que usted
            especifica a los elementos de la matriz y luego devuelven <code>true</code> o <code>false</code>. El método
            <code>every()</code> es como el
            cuantificador matemático ∀ "para todos" devuelve: <code>true</code> si y solo si su función de predicado
            devuelve verdadero para todos los elementos de la matriz:
            <code>
                <pre>
                    a = [1,2,3,4,5];
                    a.every(function(x) { return x < 10; })      // => true: all values < 10.
                    a.every(function(x) { return x % 2 === 0; }) // => false: not all values even.
                </pre>
            </code>
            El método <code>some()</code> es como el cuantificador matemático "existe" ∃: devuelve <code>true</code> si
            existe al
            menos un elemento en la matriz para el cual el predicado devuelve <code>true</code> y devuelve
            <code>false</code> si y solo si el
            predicado devuelve <code>false</code> para todos los elementos de la matriz:
            <code>
                <pre>
                    a = [1,2,3,4,5];
                    a.some(function(x) { return x%2===0; }) // => true a tiene algunos números pares.
                    a.some(isNaN)                           // => false: a no tiene no números.
                </pre>
            </code>
            Tenga en cuenta que ambos <code>every()</code> y <code>some()</code> dejan de iterar elementos de la matriz
            tan pronto como saben
            qué valor devolver. <code>some()</code> devuelve <code>true</code> la primera vez que su predicado devuelve
            <code>true</code> y solo
            itera a través de toda la matriz si su predicado siempre devuelve <code>false</code>. <code>every()</code>
            es lo contrario: devuelve
            <code>false</code> la primera vez que su predicado devuelve <code>false</code>, y solo itera todos los
            elementos si su predicado
            siempre devuelve <code>true</code>. Tenga en cuenta también que, por convención matemática,
            <code>every()</code> devuelve
            <code>true</code> y <code>some</code> devuelve <code>false</code> cuando se invoca en una matriz vacía.
        </p>
    </div>
    <div>
        <p>
            <h3>7.9.5 reduce(), reduceRight()</h3>
            Los métodos <code>reduce()</code> y <code>reduceRight()</code> combinan los elementos de una matriz,
            utilizando la función que
            especifique, para producir un solo valor. Esta es una operación común en la programación funcional y también
            se conoce con los nombres "inyectar" y "doblar". Los ejemplos ayudan a ilustrar cómo funciona:
            <code>
                <pre>
                    var a = [1,2,3,4,5]
                    var sum = a.reduce(function(x,y) { return x+y }, 0);     // Sum of values
                    var product = a.reduce(function(x,y) { return x*y }, 1); // Product of values
                    var max = a.reduce(function(x,y) { return (x>y)?x:y; }); // Largest value
                </pre>
            </code>
            <code>reduce()</code> toma dos argumentos. La primera es la función que realiza la operación de reducción.
            La tarea de
            esta función de reducción es de alguna manera combinar o reducir dos valores en un solo valor, y devolver
            ese valor reducido. En los ejemplos anteriores, las funciones combinan dos valores agregándolos,
            multiplicándolos y eligiendo el más grande. El segundo argumento (opcional) es un valor inicial para pasar a
            la función. <br><br>
            Las funciones utilizadas con <code>reduce()</code> son diferentes a las funciones utilizadas con
            <code>forEach()</code> y <code>map()</code>. El
            valor familiar, el índice y los valores de la matriz se pasan como segundo, tercer y cuarto argumento. El
            primer argumento es el resultado acumulado de la reducción hasta ahora.
            En la primera llamada a la función, este primer argumento es el valor inicial que pasó como segundo
            argumento para <code>reduce()</code>. En llamadas posteriores, es el valor devuelto por la invocación previa
            de la
            función. En el primer ejemplo anterior, la función de reducción es
            primero se llama con los argumentos 0 y 1. Agrega estos y devuelve 1. Luego se vuelve a llamar con los
            argumentos 1 y 2 y devuelve 3. Luego calcula 3 + 3 = 6, luego 6 + 4 = 10 y finalmente 10+ 5 = 15. Este valor
            final, 15, se convierte en el valor de retorno de <code>reduce()</code>. <br> <br>
            Es posible que haya notado que la tercera llamada a <code>reduce()</code> anterior tiene un solo argumento:
            no se
            especifica ningún valor inicial. Cuando invocas <code>reduce()</code> como este sin valor inicial, usa el
            primer
            elemento de la matriz como valor inicial. Esto significa que la primera llamada a la función de reducción
            tendrá el primer y el segundo elemento de matriz como su primer y segundo argumento. En los ejemplos de suma
            y producto anteriores, podríamos haber omitido el argumento del valor inicial. <br><br>
            Llamar a <code>reduce()</code> en una matriz vacía sin argumento de valor inicial provoca un TypeError. Si
            lo llama con
            un solo valor, ya sea una matriz con un elemento y sin valor inicial o una matriz vacía y un valor inicial,
            simplemente devuelve ese valor sin llamar a la función de reducción. <br><br>
            <code>reduceRight()</code> funciona igual que <code>reduce()</code>, excepto que procesa la matriz desde el
            índice más alto al más
            bajo (de derecha a izquierda), en lugar de desde el más bajo al más alto. Es posible que desee hacer esto si
            la operación de reducción tiene prioridad de derecha a izquierda, por ejemplo:
            <code>
                <pre>
                    var a = [2, 3, 4]
                    // Compute 2^(3^4). Exponentiation has right-to-left precedence
                    var big = a.reduceRight(function(accumulator,value) {
                                                return Math.pow(value,accumulator);
                                            });
                </pre>
            </code>
            Tenga en cuenta que ni <code>reduce()</code> ni <code>reduceRight()</code> acepta un argumento opcional que
            especifica el valor en
            el que se invoca la función de reducción. El argumento opcional del valor inicial toma su lugar. Consulte el
            método <code>Function.bind()</code> si necesita invocar su función de reducción como método de un objeto en
            particular.<br><br>
            Vale la pena señalar que los métodos <code>every ()</code> y <code>some ()</code> descritos anteriormente
            realizan un tipo
            de operación de reducción de matriz. Sin embargo, difieren de <code>reduce ()</code> en que terminan
            temprano cuando sea posible, y no siempre visite todos los elementos de la matriz.<br><br>
            <p>
                Los ejemplos mostrados hasta ahora han sido numéricos por simplicidad, pero <code>reduce()</code> y
                <code>reduceRight()</code>
                no están destinados únicamente a cálculos matemáticos. Considere la función <code>union()</code> del <a
                    href="#E6-2">Ejemplo 6-2</a>.
                Calcula la "unión" de dos objetos y devuelve un nuevo objeto que tiene las propiedades de ambos. Esta
                función espera dos objetos y devuelve otro objeto, por lo que funciona como una función de reducción, y
                podemos usar <code>reduce()</code> para generalizarlo y calcular la unión de cualquier número de
                objetos:
            </p>

        </p>
        <code>
            <pre>
                var objet = [{x:1}, {y:2},{z:3}];
                var merged = objects.reduce(union);  // => {x:1, y:2, z:3}
            </pre>
        </code>
        <p>
            Recuerde que cuando dos objetos tienen propiedades con el mismo nombre, la función <code>union()</code> usa
            el valor de
            esa propiedad del primer argumento. Por lo tanto <code>reduce()</code> y <code>reduceRight()</code> pueden
            dar resultados
            diferentes cuando se usan con <code>union()</code>:
        </p>
        <code>
            <pre>
                var objects = [{x:1,a:1},{y:2,a:2},{z:3,a:3}];
                var leftunion = objects.reduce(union);       // {x:1, y:2, z:3, a:1}
                var rightunion = objects.reduceRight(union); // {x:1, y:2, z:3, a:3}

            </pre>
        </code>
    </div>
    <div>
        <p>
            <h3>
                7.9.6 indexOf() and lastIndexOf()
            </h3>

        </p>
        <p>
            <code>indexOf()</code> y <code>lastIndexOf()</code> buscan en una matriz un elemento con un valor
            especificado y devuelven el índice
            del primer elemento encontrado, o –1 si no se encuentra ninguno. <code>indexOf()</code> busca la matriz de
            principio a
            fin, y <code>lastIndexOf()</code> busca de fin a principio.
        </p>
        <code>
            <pre>
                a = [0,1,2,1,0];
                a.indexOf(1)         // => 1: a[1] is 1
                a.lastIndexOf(1)     // => 3: a[3] is 1
                a.indexOf(3)         // => -1: no element has value 3
                                
            </pre>
        </code>
        <p>
            A diferencia de los otros métodos descritos en esta sección, <code>indexOf()</code> y
            <code>lastIndexOf()</code> no toman un
            argumento de función. El primer argumento es el valor a buscar. El segundo argumento es opcional: especifica
            el índice de matriz en el que comenzar la búsqueda. Si se omite este argumento, <code>indexOf()</code>
            comienza al
            principio y <code>lastIndexOf()</code> comienza al final. Los valores negativos se permiten para el segundo
            argumento y
            se tratan como un desplazamiento desde el final de la matriz, como lo son para el método
            <code>splice()</code>: un valor
            de –1, por ejemplo, especifica el último elemento de la matriz.
        </p>
        <p> La siguiente función busca en una matriz un valor especificado y devuelve una matriz de <em>todos</em> los índices
            coincidentes. Esto demuestra cómo se puede usar el segundo argumento para <code>indexOf()</code> para encontrar
            coincidencias más allá del primero.
        </p>
        <code>
            <pre>
                // Find all occurrences of a value x in an array a and return an array
                // of matching indexes
                function findall(a, x) {
                var results = [],               // The array of indexes we'll return
                    len = a.length,             // The length of the array to be searched
                    pos = 0;                    // The position to search from
                while(pos < len) {              // While more elements to search...
                    pos = a.indexOf(x, pos);    // Search
                    if (pos === -1) break;      // If nothing found, we're done.
                    results.push(pos);          // Otherwise, store index in array
                    pos = pos + 1;              // And start next search at next element
                }
                return results;                 // Return array of indexes
                }
            </pre>
        </code>
        <p>
            Tenga en cuenta que las cadenas tienen métodos <code>indexOf()</code>  y <code>lastIndexOf()</code> que funcionan como estos métodos de matriz.
        </p>
    </div>
    <p>
                <h3>
                    7.10 Array Type
                </h3>
                Hemos visto a lo largo de este capítulo que las matrices son objetos con un comportamiento especial. Dado un objeto desconocido, a menudo es útil poder determinar si es una matriz o no. En ECMAScript 5, puede hacer esto con la función <code>Array.isArray()</code> :
                <code>
                    <pre>
                        Array.isArray([])   // => true
                        Array.isArray({})   // => false       

                    </pre>
                </code>
                Antes de ECMAScript 5, sin embargo, distinguir las matrices de los objetos sin matriz era sorprendentemente difícil. El operador <code>typeof</code> no ayuda aquí: devuelve "objeto" para matrices (y para todos los objetos que no sean funciones). El operador <code>instanceof</code> funciona en casos simples:   
                <code>
                    <pre>
                        [] instanceof Array   // => true
                        ({}) instanceof Array // => false
                    </pre>
                </code>
            </p>
</body>

</html>